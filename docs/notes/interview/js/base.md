---
sidebar: 'auto'
---

# js面试题
## `js`基本数据类型有哪些
* 基本类型`Number` 、`String`、`Boolean`、`Null`、`Undefined`
* 引用类型`Object`

## `JS`当中的`typeof`返回的类型有哪些？
* `number` 、`string` 、`boolean` 、 `undefined` 、`function` 、`object`

## `return`，`break`，`continue`的区别？
* `return`：必须写在函数内部，遇到`return`后函数内部剩余的代码不再执行，直接返回；还可以使用`return`返回一个值给外面使用
* `break`：跳出循环，剩余的循环不再执行 
* `continue`：跳出本次循环，剩余的循环继续执行

## `typeof`和`instance of`的区别？
* `typeof`判断对象的类型，返回值有6种可能
* `instance of`判断是否是对方的实例化对象，返回值为`true`或者`false`

## `==`（宽松相等）和 `===`（严格相等）的区别？
* == 判断左右两边的值是否一致，但是只能判断值，不能判断类型，也就是说 2 =='2'是成立的
* === 既判断值，也判断类型

## `js`的强制转换和隐式转换是怎样的？
* `parseInt`、`parseFloat`、`Number` 这三种是强制转换
* `-=`、`*=`、`/=`、`%=` 是隐式转换 

## `get`请求和`post`请求的区别?
* `get`请求将参数放在`url`当中，`post`请求将参数放在请求体当中，理论上`post`更安全因为`url`长度大小不能超过`1KB`，而`get`请求又将参数放在`url`当中，所以上传头像等操作不能使用`get`请求

## 什么是冒泡和捕获？
* 当一个子标签触发某一个事件(比如`click`)后，该事件会从顶级父标签一级一级往该标签传递，这个过程叫做挖洞（捕获）
* 当找到该子标签之后事件会再从子标签开始一级一级往父标签传递，这个过程叫做冒泡

## `js`当中的事件委托是怎么回事？
* 用事件冒泡的原理，自己所触发的事件， 让他的父元素代替执行

## `call`、`apply`、和`bind`的区别？
* 都可以更改`this`指向
* `call`，`bind`后面的第一个参数是指向的对象，第二个参数是往对象传的值
* `apply`后面的第一个参数是指向的对象，第二个参数是数组，数组里面是往对象传的值（`arguments`全部参数）
* `call`和`apply`更改`this`指向会自动调用，`bind`需要手动调用

## `jsonP`的作用是什么，原理？
* 作用:解决跨域问题
* 原理:动态创建`script`标签，回调函数

## `cookie`、`sessionStorage`、`localStorage`的区别？
* 都可以用来存储数据
* `cookie`一条数据大小不能超过4KB ，最多不能存储超过20条，如果没有设置过期时间，那么在浏览器关闭后消失
* `sessionStorage`是会话存储，一条大小不能超过5M，数量没有限制，关掉页面数据消失
* `localStorage`本地存储，一条大小不超过5M，数量没有限制，除非主动删除，否则数据不会消失

## 原型的概念
* `JavaScript`的所有对象中都包含了一个 `proto` 内部属性，这个属性所对应的就是自身的原型`JavaScript`的函数对象，除了原型 `proto` 之外，还有 `prototype` 属性，当函数对象作为构造函数创建实例时，该 `prototype` 属性值将被作为实例对象的原型 `proto`

## 什么是原型链？
* 一个对象A调用方法的时候，会先从自身找有没有这个方法，如果没有就找自己的原型，看有没有该方法，没有就继续找对象A的父类B的原型，就这样一级一级往上找，称之为原型链。
* 任何一级找到就直接调用，不再往上找，如果到最后都没找到就报错

## 什么是闭包？
* 闭包指的是一个函数可以访问另一个函数作用域中变量

## 同步异步的区别是什么？
* 同步流程:提交请求→等待服务器处理→处理完毕返回 
> 一次请求之后必须处理完毕后才能处理后续操作，处理效率较低。（例如B/S模式）
* 异步流程:提交请求→服务器处理→处理完毕
> 发送请求后不需要等待，可以继续执行后续操作。
> 当有消息返回时系统会通知进程进行处理，可以提高执行效率。（例如AJAX技术）

## `ES6`语法的新增特性有哪些？
* let关键字，声明变量、const关键字，声明常量
* 模板字符串
* 箭头函数
* 对象和数组解构
* Set集合和Map集合
* Promise对象
* 引入class关键字<br/>
······

## `var`和`let`的区别有哪些？
* 可以用`var`对同一个变量重复声明，但是`let`不可以
* `var`有变量提升，可以先赋值，后声明。`let`没有变量提升，只能先声明，后赋值
* `let`声明的变量 有块级作用域

## 严格模式有哪些特性？
* 变量必须先声明 在使用  变量提升没了
* 严格模式下 删除后的变量不能使用 
* 严格模式下 函数内部的this指向默认指向的是 undefind 
* 严格模式下 定时器 延时器内部的this指向的还是window 
* 严格模式下 函数的参数的名字不能一样
* 严格模式下 块级作用域当中不能声明函数

## `export default` 和 `exports`有什么区别？

* 前者是默认导出，每个模块只能有一个，导入的时候需要用 `import XX from‘XXX’`这种方式
* 后者是导出，每个模块可以有多个，导入的时候需要用`import {XX} from‘XX’`的方式  
如果在一个模块中没有向外暴露成员，其他模块引入该模块时将会得到一个空对象

